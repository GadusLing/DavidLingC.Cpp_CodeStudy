#define _CRT_SECURE_NO_WARNINGS


#include <stdio.h>

//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//
//	//for (i = 0; i <= 12; i++)
//	//{
//	//	arr[i] = 0;
//	//	printf("hehe\n");
//	//}
//
//	return 0;
//}


//数值有不同表示形式
//2进制        0b10101   0b是二进制
//8进制        025       0是8进制
//10进制       21
//16进制       0x15      0x是16进制
//
//
//
//
//
//
//整数的2进制表示也有三种表示形式:
// 1.正的整数，原码、反码、补码相同
// 2.负的整数，原码、反码、补码是需要计算的
//原码:直接通过正负的形式写出的二进制序列就是原码
//反码:原码的符号位不变，其他位按位取法得到的就是反码
//补码:反码+1就是补码
//整数内存中存放是补码的二进制序列


//int main()
//{
//	int a = 20;
//	//20
//    //00000000000000000000000000010100
//	//0x00 00 00 14                      为了方便表示，我们把每4个2进制位写成一个16进制位
//    //00000000000000000000000000010100
//    //00000000000000000000000000010100
//
//	int b = -10;
//	//10000000000000000000000000001010 -原
//	//0x80 00 00 0a
//	//11111111111111111111111111110101 -反
//	//0xff ff ff f5
//	//11111111111111111111111111110110 -补
//	//0xff ff ff f6
//	//
//
//
//	return 0;
//}



//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//
//
//int main()
//{
//	if (check_sys())
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//
//	return 0;
//}



//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//
//	return 0;
//}
//
//
////10000000000000000000000000000001
////11111111111111111111111111111110
////11111111111111111111111111111111


//#include <stdio.h>
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000    -128的原码
//	//11111111111111111111111101111111    -128的反码 
//	//11111111111111111111111110000000    -128的补码
//	//10000000   截断后放到有符号char里的补码
//	//11111111111111111111111110000000   有符号char补1整型提升后
//	printf("%u\n", a);//%u会认为上面的码没有符号，会读成一个巨大的正数  4294967168
//	//如果用%d来打印，则会认为高位为符号位，会转化为补码再打印，就是-128
//	//10000000000000000000000001111111
//	//10000000000000000000000010000000   -128
//	//
//	//
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000   128的原反补码
//	//10000000    截断后放到char a里面 首位会被当成负数
//	//
//	//11111111111111111111111110000000
//
//	printf("%u\n", a);
//
//	return 0;
//}


//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100  原
//	//11111111111111111111111111101011  反
//	//11111111111111111111111111101100  补
//	
//	unsigned int j = 10;
//	//00000000000000000000000000001010  原反补
//	// 
//	//11111111111111111111111111110110 两数相加
//	//10000000000000000000000000001001 因为用%d输出，会认为首位为符号位，负数，于是取反
//	//10000000000000000000000000001010 取反后+1形成补码，最终输出为-10
//
//
//	printf("%d\n", i + j);
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//
//	return 0;
//} 


//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	return 0;
//}


//#include <stdio.h>
//unsigned char i = 0;
//
//int main()
//{
//	for (i = 0; i <= 255; i++)//char最大值是255，死循环
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}



//#include <string.h>
//int main()
//{
//	//int len = strlen("abcdef");
//	//printf("%d\n", len);
//
//	if (strlen("abc") - strlen("abcdef") >= 0)//strlen返回值类型是size_t, 相当于unsigned int, 所以打印大于
//		printf(">\n");
//	else
//		printf("<\n");
//	return 0;
//}


//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("n的值为: %d\n", n);
//	printf("*pFloat的值为:%f\n", *pFloat);
//	*pFloat = 9.0;
//	printf("num的值为: %d\n", n);
//	printf("*pFloat的值为:%f\n", *pFloat);
//	
//	return 0;
//}

//int main()
//{
//	float f = 5.5f;
//	//5.5
//	//101.1
//	//1.011 * 2^2
//	//(-1)^0 * 1.011 * 2^2
//	//S=0    M=1.011    E=2
//	// 
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//0x40  b0  00  00
//	//2+127 = 129
//
//
//	//E中有1也有0
//	//0 10000001 01100000000000000000000
//	//(-1)^0 * 1.01100000000000000000000 * 2^2
//
//	//E中全0
//	//特殊情况见文档p97 
//	//E中全1
//	//特殊情况见文档p97
//
//}


//此时回过头看看这个题目
int main()
{
	int n = 9;
	//00000000000000000000000000001001   存在内存里的补码
	
	float* pFloat = (float*)&n;
	// 

	printf("n的值为: %d\n", n);//9   这个很简单，整形进整形出，没啥好说的

	printf("*pFloat的值为:%f\n", *pFloat);
	//0 00000000 00000000000000000001001
	//此时E为全0  E= 1-127 =-126
	//(-1)^0 * 0.00000000000000000001001 * 2^-126   这就是还原后的结果，无限接近0的一个数字   0.000000保留小数点后六位输出

	*pFloat = 9.0;
	//1001.0          *pFloat =  (float*)&n   此时是把9.0浮点数存到&n里面
	//n原本是 00000000000000000000000000001001 按照浮点数规则存的是 01000001001100000000000000000000 这串码，但n往外拿的时候还是当整形在看
	//(-1) ^ 0 * 1.001 * 2^3
	//S=0  E=3  M=1.001
	//0 10000010 01100000000000000000000
	//01000001001100000000000000000000

	printf("num的值为: %d\n", n);//这里调n又是当整形在调，因为n原本就是int类型  调出来就是一个巨大的数 1091567616

	printf("*pFloat的值为:%f\n", *pFloat);//这个就比较简单了，浮点数指针进，浮点数指针出，9.000000
	
	return 0;
}