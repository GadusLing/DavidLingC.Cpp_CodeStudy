#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//int main()
//{
//	int a = 7 % 2;//1
//	int b = 7 / 2;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//3
//
//	return 0;
//}
//// % 取模操作符的两端必须是整数



//16进制
// 0~9  a~f
// 0~9 10~15
// 
//10进制
//8~9组成
//
//2进制
//0~1组成
//
//8进制
//0~7组成
//
//24进制-小时  12进制-月份
//
//
//整数的二进制表示有三种
//原码
//反码
//补码
// 
//正的整数的原码、反码、补码相同
//负的整数的原码、反码、补码是要计算的
//
//7
//00000000000000000000000000000111  原码
//00000000000000000000000000000111  反码
//00000000000000000000000000000111  补码
//
//-7
//10000000000000000000000000000111  原码
//11111111111111111111111111111000  反码  （原码的符号位不变，其他位按位取反就是反码）
//11111111111111111111111111111001  补码  （反码+1就是补码）
//
//整数在内存中存储的是补码
//所以移位操作符移动的也是补码
//
//

//int main()
//{
//	int a = -7;
//	//左移操作符
//	//移动的是二进制位
//	int b = a << 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}

//int main()
//{
//	int a = -7;
//	int b = a >> 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}


//& - 按(2进制)位与
//| - 按(2进制)位或
//^ - 按(2进制)位异或
	
//int main()
//{
//	int a = 3;
//	int b = -5;
//	int c = a ^ b;
//
//	printf("%d\n", c);
//	return 0;
//}

//3
//00000000000000000000000000000011  原
//00000000000000000000000000000011  反
//00000000000000000000000000000011  补
//
//-5
//10000000000000000000000000000101  原
//11111111111111111111111111111010  反
//11111111111111111111111111111011  补
//
//
//  
//00000000000000000000000000000011  补
//11111111111111111111111111111011  补  
//两个值的补码进行按位与，同时为1才为1，有0则为0

//%d 意味着打印一个有符号的整数，下面首位是0，表示正数，原反补相同，所以最终是3
//00000000000000000000000000000011  3


//或，两个值的补码进行按位或，只要有1就为1，同时0才为0
//00000000000000000000000000000011   3补
//11111111111111111111111111111011  -5补
//
//11111111111111111111111111111011
//11111111111111111111111111111010
//10000000000000000000000000000101  -5



//异或，两个值的补码进行按位与，相异为1，相同为0
//00000000000000000000000000000011   3补
//11111111111111111111111111111011  -5补
//
//11111111111111111111111111111000
//11111111111111111111111111110111
//10000000000000000000000000001000   -8



//来一道面试题
//不能创建临时变量(第三个变量)，实现两个数的交换。
//正常会怎么做？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int tmp = 0;
//	printf("交换前：%d %d", a, b);
//	tmp = a;
//	a = b;
//	b = tmp;
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}

//如果不用第三个变量呢？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：%d %d", a, b);
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}

//ok，但是上面的方法会有溢出的风险，那现在不用任何变量怎么做？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：%d %d", a, b);
//	a = a ^ b;//a = 3^5
//	b = a ^ b;//3^5^5  b = 3
//	a = a ^ b;//3^5^3  a = 5
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}
//为什么会这样，首先两个相同的数字异或^为0
//比如3^3
//011
//011
//000
//那0^5的结果是什么呢？
//000
//101
//结果还是101---5
//所以结论是   0^a = a;  a^a = 0;
//所以3^3^5 = 5

//所以计算一下3^5^3 = ?
//011
//101
//110
//011
//101
//所以最后结果还是5  3^5^3 = 5
//结论是――――异或支持交换律
//所以再回上面去看最后的计算结果
//
//最终，这样的交换不会导致溢出，很棒
//但是注意！！！！实际开发过程中创建临时变量交换的方法运用的最为广泛，因为它的执行速度最快
//并且异或只适用于整数，整体的泛用性不如tmp交换，可读性也很差，不要为了装逼而自找麻烦
//

//编写代码实现:求一个整数存储在内存中的二进制中1的个数。
//也就是求补码的二进制中1的个数
//
//int a = 3;
//00000000000000000000000000000011
//
//a&1
//00000000000000000000000000000011
//00000000000000000000000000000001
//00000000000000000000000000000001  结果是1
//来实现一下
//int main()
//{
//	int n = 3;
//	int count = 0;
//	while (n != 0)
//	{
//		if (n & 1)
//		{
//			count++;
//		}
//		n = n >> 1;
//	}
//	printf("%d", count);
//
//
//	return 0;
//}

//int main()
//{
//	int a = 3;//初始化
//
//	int b = 0;//初始化
//	b = 20;//赋值
//
//	return 0;
//}


//int main()
//{
//	int a = 3;
//	a = a + 5;
//	a += 5;
//
//	a = a >> 1;
//	a >>= 1;
//
//	return 0;
//}


//int main()
//{
//	int flag = 3;
//	//flag为真，进入if
//	if (flag)
//	{
//
//	}
//	//flag为假，进入if
//	if (!flag)
//	{
//
//	}
//	return 0;
//}
//C语言中0为假，非0为真

//int main()
//{
//	int a = +10;
//	int b = +a;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);
//	int* p = &a;//p就是指针变量
//
//
//	return 0;
//}


//int main()
//{
//	int a = 10;
//	int n = sizeof(a);//sizeof计算的是a所占的内存大小，单位是字节
//	//sizeof是一个操作符
//	//计算的是变量所占内存空间的大小，单位是字节
//	//计算类型所创建的变量占据空间的大小，单位是字节
//	printf("n = %d\n", n);
//
//	return 0;
//}

//int main()
//{
//	int arr[5] = { 0 };
//	printf("%d\n", sizeof(arr));
//
//
//
//	return 0;
//}


//关于~的一些知识
//int main()
//{
//	//int a = 0;
//	////~是按二进制位取反
//	////00000000000000000000000000000000 - 补
//	////11111111111111111111111111111111 - ~a
//	////11111111111111111111111111111110  负数补码原码变先减1变反码
//	////10000000000000000000000000000001  再取反变原码
//	////最后结果是-1
//	//printf("%d\n", ~a);
//
//	//int a = 3;
//	////00000000000000000000000000000011
//	////11111111111111111111111111111100
//	////11111111111111111111111111111011
//	////10000000000000000000000000000100
//	////结果是-4
//	//printf("%d\n", ~a);
//
//	int a = 13;
//	a |= (1 << 4);//或等
//	a &= (~(1 << 4));
//	printf("%d\n", a);
//	//00000000000000000000000000001101    &=
//	//00000000000000000000000000011101    &=
//	//11111111111111111111111111101111    &= 
//	//00000000000000000000000000010000    ~(1 << 4)
//	// 
//	// 
//	// 
//	//00000000000000000000000000000010
//	//1 << 1
//	//00000000000000000000000000001111
//
//
//	return 0;
//}

//int main()
//{
//	//int a = 3;
//	//int b = ++a;//前置++，先++，后使用
//	////a=a+1,b=a  
//	//printf("%d\n", a);//4
//	//printf("%d\n", b);//4
//
//	//int a = 3;
//	//int b = a++;//后置++，先使用，后++
//	////b=a,a=a+1
//	//printf("%d\n", a);//4
//	//printf("%d\n", b);//3
//
//	//int a = 3;
//	//int b = --a;//前置--同理
//	////a=a-1,b=a
//	//printf("%d\n", a);//2
//	//printf("%d\n", b);//2
//
//	//int a = 3;
//	//int b = a--; //后置--同理
//	////b=a,a=a-1
//	//printf("%d\n", a);//2
//	//printf("%d\n", b);//3
//
//	int a = 10;
//	printf("%d\n", a--);
//	printf("%d\n", a);
//
//
//	return 0;
//}

//int main()
//{
//	int a = 0;
//	int* p = &a;
//	*p = 20;
//	printf("%d\n", a);
//	return 0;
//}

//int main()
//{
//	time_t;
//	srand((unsigned int)time(NULL));
//	int a = (int)3.14;
//	printf("%d\n", a);
//	return 0;
//}


//int main()
//{
//	if (3 == 5)
//	{
//
//	}
//	if ("abc" == "abcdef")//这里不能这样比，这不是在比内容，而是在比两个字符串首字符的地址，比内容应该用strcmp
//	{
//
//	}
//
//
//	return 0;
//}


//int main()
//{
//	int a = 3;
//	int b = 0;
//	int c = a && b;//注意这里是逻辑与，只关注真假，结果是1 or 0，这里两个数都非0为真，所以结果也是真――――1
//	c = a || b;//注意这里是逻辑或，只有一个真就为真了
//	printf("%d\n", c);
//	//if (a && b)
//	//{
//
//	//}
//
//
//	return 0;
//}



////1.能被4整除，并且不能被100整除
////2.能被400整除是闰年
//is_leap_year(int y)
//{
//	if ((y % 4 == 0) && (y % 100 != 0) || (y % 400 == 0))
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}
//
//int main()
//{
//	return 0;
//}



//// &&左边为假，右边就不计算了
//// ||左边为真，右边就不计算了
//#include <stdio.h>
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;//一个经典的短路问题，从a++的a开始就为假了，所以只计算了a后置的一个++，后面都不算了，所以结果为1234
//	
//	i = a++||++b||d++;//这里也是近似的道理，如果前面已经发现了满足或的条件，判断整个i为真了，后面无论是前置还是后置++都不计算了
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//	return 0;
//}


//int main()
//{
//	int a = 3;
//	int b = 0;
//	int max = (a > b ? a : b);
//	if (a > 5)
//	{
//		b = 3;
//	}
//	else
//	{
//		b = -3;
//	}
//	(a > 5) ? (b = 3) : (b = -3);
//	b = (a > 5 ? 3 : -3);
//
//	return 0;
//}


//int main()
//{
//
//	int arr[10] = { 0 };
//	//arr[7] --> *(arr+7) --> *(7+arr)
//	//arr是数组首元素的地址
//	//arr+7就是跳过7个元素，指向了第8个元素
//	//*(arr+7)就是第8个元素
//
//
//	arr[7] = 8;
//	7[arr] = 9;
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	int b = 20;
//	//函数调用
//	int c = Add(a, b);//这里的小圆括号()就是函数调用操作符，操作数：Add,a,b，操作数至少有一个――――函数名
//
//	return 0;
//}

struct Stu
{
	char name[20];
	int age;
	double score;
};

void set_stu(struct Stu* ps)
{
	/*strcpy((*ps).name, "zhangsan");
	(*ps).age = 20;
	(*ps).score = 100.0;*/

	strcpy(ps->name, "zhangsan");
	ps->age = 20;
	ps->score = 100.0;
}

void print_stu(struct Stu ss)
{
	printf("%s %d %lf\n", ss.name, ss.age, ss.score);
}

int main()
{
	struct Stu s = { 0 };
	set_stu(&s);
	print_stu(s);

	return 0;
}














