#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//int main()
//{
//	int a = 7 % 2;//1
//	int b = 7 / 2;
//	printf("%d\n", a);//1
//	printf("%d\n", b);//3
//
//	return 0;
//}
//// % 取模操作符的两端必须是整数



//16进制
// 0~9  a~f
// 0~9 10~15
// 
//10进制
//8~9组成
//
//2进制
//0~1组成
//
//8进制
//0~7组成
//
//24进制-小时  12进制-月份
//
//
//整数的二进制表示有三种
//原码
//反码
//补码
// 
//正的整数的原码、反码、补码相同
//负的整数的原码、反码、补码是要计算的
//
//7
//00000000000000000000000000000111  原码
//00000000000000000000000000000111  反码
//00000000000000000000000000000111  补码
//
//-7
//10000000000000000000000000000111  原码
//11111111111111111111111111111000  反码  （原码的符号位不变，其他位按位取反就是反码）
//11111111111111111111111111111001  补码  （反码+1就是补码）
//
//整数在内存中存储的是补码
//所以移位操作符移动的也是补码
//
//

//int main()
//{
//	int a = -7;
//	//左移操作符
//	//移动的是二进制位
//	int b = a << 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}

//int main()
//{
//	int a = -7;
//	int b = a >> 1;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}


//& - 按(2进制)位与
//| - 按(2进制)位或
//^ - 按(2进制)位异或
	
//int main()
//{
//	int a = 3;
//	int b = -5;
//	int c = a ^ b;
//
//	printf("%d\n", c);
//	return 0;
//}

//3
//00000000000000000000000000000011  原
//00000000000000000000000000000011  反
//00000000000000000000000000000011  补
//
//-5
//10000000000000000000000000000101  原
//11111111111111111111111111111010  反
//11111111111111111111111111111011  补
//
//
//  
//00000000000000000000000000000011  补
//11111111111111111111111111111011  补  
//两个值的补码进行按位与，同时为1才为1，有0则为0

//%d 意味着打印一个有符号的整数，下面首位是0，表示正数，原反补相同，所以最终是3
//00000000000000000000000000000011  3


//或，两个值的补码进行按位或，只要有1就为1，同时0才为0
//00000000000000000000000000000011   3补
//11111111111111111111111111111011  -5补
//
//11111111111111111111111111111011
//11111111111111111111111111111010
//10000000000000000000000000000101  -5



//异或，两个值的补码进行按位与，相异为1，相同为0
//00000000000000000000000000000011   3补
//11111111111111111111111111111011  -5补
//
//11111111111111111111111111111000
//11111111111111111111111111110111
//10000000000000000000000000001000   -8



//来一道面试题
//不能创建临时变量(第三个变量)，实现两个数的交换。
//正常会怎么做？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int tmp = 0;
//	printf("交换前：%d %d", a, b);
//	tmp = a;
//	a = b;
//	b = tmp;
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}

//如果不用第三个变量呢？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：%d %d", a, b);
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}

//ok，但是上面的方法会有溢出的风险，那现在不用任何变量怎么做？
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：%d %d", a, b);
//	a = a ^ b;//a = 3^5
//	b = a ^ b;//3^5^5  b = 3
//	a = a ^ b;//3^5^3  a = 5
//	printf("交换后：%d %d", a, b);
//
//	return 0;
//}
//为什么会这样，首先两个相同的数字异或^为0
//比如3^3
//011
//011
//000
//那0^5的结果是什么呢？
//000
//101
//结果还是101---5
//所以结论是   0^a = a;  a^a = 0;
//所以3^3^5 = 5

//所以计算一下3^5^3 = ?
//011
//101
//110
//011
//101
//所以最后结果还是5  3^5^3 = 5
//结论是――――异或支持交换律
//所以再回上面去看最后的计算结果
//
//最终，这样的交换不会导致溢出，很棒
//但是注意！！！！实际开发过程中创建临时变量交换的方法运用的最为广泛，因为它的执行速度最快
//并且异或只适用于整数，整体的泛用性不如tmp交换，可读性也很差，不要为了装逼而自找麻烦
//

//编写代码实现:求一个整数存储在内存中的二进制中1的个数。
//也就是求补码的二进制中1的个数
//
//int a = 3;
//00000000000000000000000000000011
//
//a&1
//00000000000000000000000000000011
//00000000000000000000000000000001
//00000000000000000000000000000001  结果是1
//来实现一下
//int main()
//{
//	int n = 3;
//	int count = 0;
//	while (n != 0)
//	{
//		if (n & 1)
//		{
//			count++;
//		}
//		n = n >> 1;
//	}
//	printf("%d", count);
//
//
//	return 0;
//}

int main()
{
	int a = 3;//初始化

	int b = 0;//初始化
	b = 20;//赋值

	return 0;
}
