#include "Func.h"


void func1(int x)
{
	cout << "func1 = " << x << endl;
}

template <class T>
void func2(const T& x)
{
	cout << "func2 = " << x << endl;
}

// 如果硬要分离编译，也有办法，比如下面的显式实例化
template
void func2(const int& x);
// 我自己知道这个函数要实例化成int类型，所以我就显式实例化了，这样符号表里就有func2的链接，最后链接阶段就链接上了
// 但是这样做的话，就失去了模板的意义了，因为模板是为了实现通用的代码，这样用一个新类型就要显式实例化一次，太麻烦了
// 如果你要写很多显式实例化，那还不如写普通函数了

//所以还有一种方案，就是将声明和定义都放在.h文件中，这样就不会出现找不到定义的问题了，STL库里面也是这么做的
//因此有些地方会把包含模板定义的头文件尾缀定义成.hpp，但是这个不是标准，只是一种约定俗成的写法


